Texture2D<float4> _SourceTex;         

RWStructuredBuffer<float4> _SumBufferRGBA;
/////////////////////////////////////////////////
// RGBA 채널용 커널
/////////////////////////////////////////////////
#pragma kernel CSMain_RGBA
uint _WidthRGBA, _HeightRGBA;

[numthreads(16,16,1)]
void CSMain_RGBA(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= _WidthRGBA || id.y >= _HeightRGBA) return;
	float4 value = _SourceTex.Load(int3(id.x, id.y, 0));
	float occlusionValue = value.x;
	uint flatIdx = id.y * _WidthRGBA + id.x;
	_SumBufferRGBA[flatIdx] = occlusionValue;
}

#pragma kernel CSMain_Distance_Sampling

[numthreads(16,16,1)]
void CSMain_Distance_Sampling(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= _WidthRGBA || id.y >= _HeightRGBA) return;
	float4 value = _SourceTex.Load(int3(id.x, id.y, 0));
	if(value.y > 0) return;
	bool left = id.x - 1 > 0;
	bool up = id.x -1 > 0;
	bool leftUp = left && up;
	float distance = 10000f;
	if(left) distance = min(distance, _SourceTex.Load(int3(id.x - 1, id.y, 0)).y);
	if(up) distance = min(distance, _SourceTex.Load(int3(id.x, id.y - 1, 0)).y);
	if(leftUp) distance = min(distance, _SourceTex.Load(int3(id.x - 1, id.y - 1, 0)).y);
	value.y = distance;
	
	uint flatIdx = id.y * _WidthRGBA + id.x;
	_SumBufferRGBA[flatIdx] = value;
}